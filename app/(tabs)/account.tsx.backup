/**
 * Account Tab - Fully Refactored (Working Version)
 * 
 * Main orchestration component using section components
 * Reduced from 4,779 lines to ~450 lines (91% reduction)
 */

import React, { useState, useEffect, useCallback } from 'react';
import {
  ScrollView,
  View,
  Text,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  StyleSheet,
  RefreshControl,
  Linking,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { supabase } from '../../lib/supabase';
import { Colors } from '../../constants/colors';
import { uploadFileToStorage } from '../../lib/fileUpload';

// Components
import { ProfileSection } from '../../components/AccountSections/ProfileSection';
import { AnalyticsSection } from '../../components/AccountSections/AnalyticsSection';
import { EventsSection } from '../../components/AccountSections/EventsSection';
import { AppealsSection } from '../../components/AccountSections/AppealsSection';
import { TestBankSection } from '../../components/AccountSections/TestBankSection';
import { TestBankModal } from '../../components/AccountModals/TestBankModal';
import { PointAppealModal } from '../../components/AccountModals/PointAppealModal';
import { EventFeedbackModal } from '../../components/AccountModals/EventFeedbackModal';
import { DataConsentModal } from '../../components/DataConsentModal';
import * as DocumentPicker from 'expo-document-picker';

// Consent utilities
import { 
  shouldShowConsentModal, 
  saveConsentPreferences,
  getConsentPreferences,
  filterDataByConsent,
  ConsentPreferences 
} from '../../lib/dataConsent';

export default function AccountTab() {
  // Loading state
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Data state
  const [profile, setProfile] = useState<any>(null);
  const [analytics, setAnalytics] = useState<any>(null);
  const [events, setEvents] = useState<any[]>([]);
  const [appeals, setAppeals] = useState<any[]>([]);
  const [appealableEvents, setAppealableEvents] = useState<any[]>([]);
  const [submittedFeedback, setSubmittedFeedback] = useState<Set<string>>(new Set());
  const [testBankSubmissions, setTestBankSubmissions] = useState<any[]>([]);

  // UI state
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState<any>({});
  const [saving, setSaving] = useState(false);
  const [eventsExpanded, setEventsExpanded] = useState(false);
  const [achievementsExpanded, setAchievementsExpanded] = useState(false);
  const [testBankExpanded, setTestBankExpanded] = useState(false);
  
  // Data Consent Modal state
  const [consentModalVisible, setConsentModalVisible] = useState(false);
  const [userConsent, setUserConsent] = useState<ConsentPreferences | null>(null);
  
  // Test Bank Modal state
  const [testBankModalVisible, setTestBankModalVisible] = useState(false);
  const [testBankClassCode, setTestBankClassCode] = useState('');
  const [testBankFileType, setTestBankFileType] = useState<'test' | 'notes' | 'materials'>('test');
  const [testBankSelectedFile, setTestBankSelectedFile] = useState<any>(null);
  const [uploadingTestBank, setUploadingTestBank] = useState(false);
  
  // Point Appeal Modal state
  const [appealModalVisible, setAppealModalVisible] = useState(false);
  const [selectedAppealEvent, setSelectedAppealEvent] = useState<any>(null);
  const [appealReason, setAppealReason] = useState('');
  const [appealPictureUrl, setAppealPictureUrl] = useState('');
  const [submittingAppeal, setSubmittingAppeal] = useState(false);

  // Event Feedback Modal state
  const [feedbackModalVisible, setFeedbackModalVisible] = useState(false);
  const [selectedFeedbackEvent, setSelectedFeedbackEvent] = useState<any>(null);
  const [feedbackData, setFeedbackData] = useState({
    rating: 0,
    would_attend_again: null as boolean | null,
    well_organized: null as boolean | null,
    comments: '',
  });
  const [submittingFeedback, setSubmittingFeedback] = useState(false);

  // Fetch all account data
  const fetchAccountData = useCallback(async () => {
    try {
      setError(null);
      
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        setError('Not authenticated');
        return;
      }

      // Single RPC call for all data
      const { data: dashboardData, error: dashboardError } = await supabase
        .rpc('get_account_dashboard', { p_user_id: user.id });

      if (dashboardError) {
        setError(dashboardError.message);
        return;
      }

      if (!dashboardData) {
        setError('No data returned');
        return;
      }

      // Update all state
      setProfile(dashboardData.profile || null);
      setAnalytics(dashboardData.analytics || null);
      setEvents(dashboardData.events || []);
      setAppeals(dashboardData.user_appeals || []);
      setAppealableEvents(dashboardData.appealable_events || []);

      // Fetch submitted feedback
      const eventIds = (dashboardData.events || []).map((e: any) => e.id).filter(Boolean);
      if (eventIds.length > 0) {
        const { data: feedbackData } = await supabase
          .from('event_feedback')
          .select('event_id')
          .eq('user_id', user.id)
          .in('event_id', eventIds);
        
        if (feedbackData) {
          setSubmittedFeedback(new Set(feedbackData.map(f => f.event_id)));
        }
      }

      // Fetch test bank submissions
      const { data: testBankData } = await supabase
        .from('test_bank')
        .select('id, class_code, file_type, original_file_name, uploaded_at, status')
        .eq('submitted_by', user.id)
        .order('uploaded_at', { ascending: false });
      
      if (testBankData) {
        setTestBankSubmissions(testBankData);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  // Load data on mount
  useEffect(() => {
    fetchAccountData();
  }, [fetchAccountData]);

  // Check consent status on mount and load user preferences
  useEffect(() => {
    const loadConsentPreferences = async () => {
      const consent = await getConsentPreferences();
      setUserConsent(consent);
    };
    loadConsentPreferences();
  }, []);

  // Pull to refresh
  const handleRefresh = () => {
    setRefreshing(true);
    fetchAccountData();
  };

  // Logout handler
  const handleLogout = async () => {
    await supabase.auth.signOut();
  };

  // Profile editing handlers
  const startEditing = async () => {
    // Check if user needs to see consent modal first
    const needsConsent = await shouldShowConsentModal();
    
    if (needsConsent) {
      setConsentModalVisible(true);
      return;
    }

    // Proceed with editing
    setFormData({
      first_name: profile?.first_name || '',
      last_name: profile?.last_name || '',
      email: profile?.email || '',
      phone_number: profile?.phone_number || '',
      uid: profile?.uid || '',
      majors: profile?.majors || '',
      minors: profile?.minors || '',
      expected_graduation: profile?.expected_graduation || '',
      house_membership: profile?.house_membership || '',
      pronouns: profile?.pronouns || '',
      gender: profile?.gender || '',
      sexual_orientation: profile?.sexual_orientation || '',
      race: profile?.race || '',
      living_type: profile?.living_type || '',
      pledge_class: profile?.pledge_class || '',
    });
    setIsEditing(true);
  };

  const cancelEdit = () => {
    setIsEditing(false);
    setFormData({});
  };

  // Consent modal handlers
  const handleConsentAccept = async (consentOptions: { demographics: boolean; academic: boolean; housing: boolean; analytics: boolean }) => {
    try {
      // Convert to full ConsentPreferences with timestamp and version
      const consent: ConsentPreferences = {
        ...consentOptions,
        timestamp: Date.now(),
        version: '1.0.0',
      };
      
      await saveConsentPreferences(consent);
      setUserConsent(consent);
      setConsentModalVisible(false);
      
      // Now start editing with consent preferences loaded
      setFormData({
        first_name: profile?.first_name || '',
        last_name: profile?.last_name || '',
        email: profile?.email || '',
        phone_number: profile?.phone_number || '',
        uid: profile?.uid || '',
        majors: profile?.majors || '',
        minors: profile?.minors || '',
        expected_graduation: profile?.expected_graduation || '',
        house_membership: profile?.house_membership || '',
        pronouns: profile?.pronouns || '',
        gender: profile?.gender || '',
        sexual_orientation: profile?.sexual_orientation || '',
        race: profile?.race || '',
        living_type: profile?.living_type || '',
        pledge_class: profile?.pledge_class || '',
      });
      setIsEditing(true);
    } catch (error) {
      Alert.alert('Error', 'Failed to save consent preferences');
    }
  };

  const handleConsentDecline = async () => {
    // User declined - save all as false
    const declinedConsent: ConsentPreferences = {
      demographics: false,
      academic: false,
      housing: false,
      analytics: false,
      timestamp: Date.now(),
      version: '1.0.0',
    };
    
    try {
      await saveConsentPreferences(declinedConsent);
      setUserConsent(declinedConsent);
      setConsentModalVisible(false);
      
      // Start editing with no optional fields available
      setFormData({
        first_name: profile?.first_name || '',
        last_name: profile?.last_name || '',
        email: profile?.email || '',
        phone_number: profile?.phone_number || '',
        uid: profile?.uid || '',
        pledge_class: profile?.pledge_class || '',
      });
      setIsEditing(true);
    } catch (error) {
      Alert.alert('Error', 'Failed to save preferences');
    }
  };

  const saveProfile = async () => {
    setSaving(true);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      // Validate required fields
      if (!formData.first_name?.trim() || !formData.last_name?.trim()) {
        Alert.alert('Error', 'First name and last name are required');
        setSaving(false);
        return;
      }

      // Filter data based on user consent - only save data they've authorized
      const filteredData = await filterDataByConsent(formData);

      const { error } = await supabase
        .from('users')
        .update({
          ...filteredData,
          last_profile_update: new Date().toISOString(),
        })
        .eq('user_id', user.id);

      if (error) throw error;

      Alert.alert('Success', 'Profile updated successfully');
      setIsEditing(false);
      fetchAccountData();
    } catch (error) {
      Alert.alert('Error', error instanceof Error ? error.message : 'Failed to save');
    } finally {
      setSaving(false);
    }
  };

  const updateField = (field: string, value: any) => {
    setFormData((prev: any) => ({ ...prev, [field]: value }));
  };

  // Check if user can edit profile (7-day cooldown)
  const canEdit = () => {
    if (!profile?.last_profile_update) return true;
    const daysSince = Math.floor(
      (Date.now() - new Date(profile.last_profile_update).getTime()) / (1000 * 60 * 60 * 24)
    );
    return daysSince >= 7;
  };

  const nextEditDate = () => {
    if (!profile?.last_profile_update) return null;
    const next = new Date(profile.last_profile_update);
    next.setDate(next.getDate() + 7);
    return next;
  };

  // Event handlers (placeholders for now)
  const handleFeedbackPress = (event: any) => {
    setSelectedFeedbackEvent(event);
    setFeedbackModalVisible(true);
  };

  const handleAppealPress = (event: any) => {
    setSelectedAppealEvent(event);
    setAppealModalVisible(true);
  };

  // Event Feedback handlers
  const handleCloseFeedbackModal = () => {
    setFeedbackModalVisible(false);
    setSelectedFeedbackEvent(null);
    setFeedbackData({
      rating: 0,
      would_attend_again: null,
      well_organized: null,
      comments: '',
    });
  };

  const handleUpdateFeedback = <K extends keyof typeof feedbackData>(
    field: K,
    value: typeof feedbackData[K]
  ) => {
    setFeedbackData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSubmitFeedback = async () => {
    try {
      setSubmittingFeedback(true);

      // Validate required fields
      if (feedbackData.rating === 0) {
        Alert.alert('Error', 'Please provide a rating');
        return;
      }

      if (feedbackData.would_attend_again === null) {
        Alert.alert('Error', 'Please indicate if you would attend again');
        return;
      }

      if (feedbackData.well_organized === null) {
        Alert.alert('Error', 'Please indicate if the event was well organized');
        return;
      }

      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        throw new Error('Not authenticated');
      }

      if (!selectedFeedbackEvent) {
        throw new Error('No event selected');
      }

      // Check if feedback already exists
      const { data: existingFeedback, error: checkError } = await supabase
        .from('event_feedback')
        .select('id')
        .eq('user_id', user.id)
        .eq('event_id', selectedFeedbackEvent.id)
        .single();

      if (checkError && checkError.code !== 'PGRST116') {
        throw checkError;
      }

      if (existingFeedback) {
        Alert.alert('Already Submitted', 'You have already submitted feedback for this event.');
        handleCloseFeedbackModal();
        return;
      }

      // Insert feedback
      const { error: insertError } = await supabase
        .from('event_feedback')
        .insert({
          user_id: user.id,
          event_id: selectedFeedbackEvent.id,
          rating: feedbackData.rating,
          would_attend_again: feedbackData.would_attend_again,
          well_organized: feedbackData.well_organized,
          comments: feedbackData.comments.trim() || null,
          created_at: new Date().toISOString(),
        });

      if (insertError) {
        throw insertError;
      }

      // Update submitted feedback set
      setSubmittedFeedback((prev) => new Set(prev).add(selectedFeedbackEvent.id));

      Alert.alert('Success', 'Thank you for your feedback!');
      handleCloseFeedbackModal();
      fetchAccountData(); // Refresh data
    } catch (error: any) {
      console.error('Error submitting feedback:', error);
      Alert.alert('Error', error.message || 'Failed to submit feedback');
    } finally {
      setSubmittingFeedback(false);
    }
  };

  // Point Appeal handlers
  const handleCloseAppealModal = () => {
    setAppealModalVisible(false);
    setSelectedAppealEvent(null);
    setAppealReason('');
    setAppealPictureUrl('');
  };

  const handleSubmitAppeal = async () => {
    try {
      setSubmittingAppeal(true);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        Alert.alert('Error', 'You must be logged in to submit an appeal.');
        return;
      }

      if (!selectedAppealEvent) {
        Alert.alert('Error', 'No event selected.');
        return;
      }

      // Check if user already has a pending appeal for this event
      const { data: existingAppeals, error: checkError } = await supabase
        .from('point_appeal')
        .select('id, status')
        .eq('user_id', user.id)
        .eq('event_id', selectedAppealEvent.id);

      if (checkError) {
        throw checkError;
      }

      // Check for pending appeals
      const hasPendingAppeal = existingAppeals?.some(
        appeal => appeal.status === 'pending'
      );

      if (hasPendingAppeal) {
        Alert.alert(
          'Appeal Already Exists',
          'You already have a pending appeal for this event. Please wait for it to be reviewed.'
        );
        return;
      }

      // Insert the appeal
      const { error: insertError } = await supabase
        .from('point_appeal')
        .insert({
          user_id: user.id,
          event_id: selectedAppealEvent.id,
          appeal_reason: appealReason.trim(),
          picture_url: appealPictureUrl.trim(),
          status: 'pending',
          created_at: new Date().toISOString(),
        });

      if (insertError) {
        throw insertError;
      }

      Alert.alert(
        'Appeal Submitted!',
        'Your appeal has been submitted and will be reviewed by an officer.',
        [{ text: 'OK', onPress: handleCloseAppealModal }]
      );

      // Refresh account data to show new appeal
      fetchAccountData();
    } catch (error: any) {
      console.error('Error submitting appeal:', error);
      Alert.alert('Submission Failed', error.message || 'Failed to submit appeal. Please try again.');
    } finally {
      setSubmittingAppeal(false);
    }
  };

  // Test Bank handlers
  const handleOpenTestBankModal = () => {
    setTestBankModalVisible(true);
  };

  const handleCloseTestBankModal = () => {
    setTestBankModalVisible(false);
    // Reset form
    setTestBankClassCode('');
    setTestBankFileType('test');
    setTestBankSelectedFile(null);
  };

  const handlePickTestBankFile = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
      });

      if (!result.canceled && result.assets && result.assets.length > 0) {
        setTestBankSelectedFile(result.assets[0]);
      }
    } catch (error) {
      console.error('Error picking file:', error);
      Alert.alert('Error', 'Failed to select file. Please try again.');
    }
  };

  const handleSubmitTestBank = async () => {
    try {
      setUploadingTestBank(true);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        Alert.alert('Error', 'You must be logged in to upload files.');
        return;
      }

      if (!testBankSelectedFile) {
        Alert.alert('Error', 'Please select a file to upload.');
        return;
      }

      // Upload file to Supabase Storage
      const fileExt = testBankSelectedFile.name.split('.').pop();
      const fileName = `${user.id}_${Date.now()}.${fileExt}`;
      
      const uploadResult = await uploadFileToStorage(
        testBankSelectedFile.uri,
        'files',
        'test-bank',
        fileName,
        testBankSelectedFile.mimeType
      );

      if (!uploadResult.success) {
        throw new Error(uploadResult.error || 'Failed to upload file');
      }
      
      // Insert record into test_bank table
      const { error: insertError } = await supabase
        .from('test_bank')
        .insert({
          class_code: testBankClassCode.toUpperCase(),
          file_type: testBankFileType,
          original_file_name: testBankSelectedFile.name,
          stored_file_name: uploadResult.filePath,
          submitted_by: user.id,
          status: 'pending',
        });

      if (insertError) {
        throw insertError;
      }

      Alert.alert(
        'Success!',
        'Your submission has been uploaded and is pending review.',
        [{ text: 'OK', onPress: handleCloseTestBankModal }]
      );

      // Refresh account data to show new submission
      fetchAccountData();
    } catch (error: any) {
      console.error('Error submitting test bank:', error);
      Alert.alert('Upload Failed', error.message || 'Failed to upload file. Please try again.');
    } finally {
      setUploadingTestBank(false);
    }
  };

  // Render loading state
  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={Colors.primary} />
          <Text style={styles.loadingText}>Loading your account...</Text>
        </View>
      </SafeAreaView>
    );
  }

  // Render error state
  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorIcon}>⚠️</Text>
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity style={styles.retryButton} onPress={fetchAccountData}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            tintColor={Colors.primary}
          />
        }
      >
        {/* Header */}
        <View style={styles.header}>
          <View>
            <Text style={styles.headerTitle}>Account</Text>
            <Text style={styles.headerSubtitle}>
              {profile?.first_name} {profile?.last_name}
            </Text>
          </View>
          <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
            <Text style={styles.logoutButtonText}>Logout</Text>
          </TouchableOpacity>
        </View>

        {/* Analytics Section */}
        <AnalyticsSection
          analytics={analytics}
        />

        {/* Profile Section */}
        <ProfileSection
          profile={profile}
          isEditing={isEditing}
          formData={formData}
          userConsent={userConsent}
          canEdit={canEdit()}
          nextEditDate={nextEditDate()}
          daysUntilEdit={profile?.last_profile_update ? Math.max(0, 7 - Math.floor((Date.now() - new Date(profile.last_profile_update).getTime()) / (1000 * 60 * 60 * 24))) : 0}
          onUpdate={updateField}
          onSave={saveProfile}
          onCancel={cancelEdit}
          onStartEdit={startEditing}
          onManageConsent={() => setConsentModalVisible(true)}
          saving={saving}
        />

        {/* Events Section */}
        <EventsSection
          events={events}
          submittedFeedback={submittedFeedback}
          onFeedbackPress={handleFeedbackPress}
          expanded={eventsExpanded}
          onToggleExpanded={() => setEventsExpanded(!eventsExpanded)}
        />

        {/* Appeals Section */}
        <AppealsSection
          userAppeals={appeals}
          appealableEvents={appealableEvents}
          onAppealPress={handleAppealPress}
          userRole={profile?.role || null}
        />

        {/* Test Bank Section */}
        <TestBankSection
          submissions={testBankSubmissions}
          expanded={testBankExpanded}
          onToggleExpanded={() => setTestBankExpanded(!testBankExpanded)}
          onUploadPress={handleOpenTestBankModal}
        />

        {/* Footer Links - Required for Apple */}
        <View style={styles.footerLinks}>
          <TouchableOpacity 
            onPress={() => Linking.openURL('https://deltasigmapi.org/privacy')}
            style={styles.footerLink}
          >
            <Text style={styles.footerLinkText}>Privacy Policy</Text>
          </TouchableOpacity>
          <Text style={styles.footerSeparator}>•</Text>
          <TouchableOpacity 
            onPress={() => Linking.openURL('https://deltasigmapi.org/terms')}
            style={styles.footerLink}
          >
            <Text style={styles.footerLinkText}>Terms of Service</Text>
          </TouchableOpacity>
          <Text style={styles.footerSeparator}>•</Text>
          <TouchableOpacity 
            onPress={() => Alert.alert('Contact', 'Email: support@deltasigmapi.org')}
            style={styles.footerLink}
          >
            <Text style={styles.footerLinkText}>Support</Text>
          </TouchableOpacity>
        </View>
        
        <Text style={styles.footerVersion}>Version 1.0.0</Text>
      </ScrollView>

      {/* Test Bank Upload Modal */}
      <TestBankModal
        visible={testBankModalVisible}
        onClose={handleCloseTestBankModal}
        onSubmit={handleSubmitTestBank}
        classCode={testBankClassCode}
        fileType={testBankFileType}
        selectedFile={testBankSelectedFile}
        onUpdateClassCode={setTestBankClassCode}
        onUpdateFileType={setTestBankFileType}
        onPickFile={handlePickTestBankFile}
      />

      {/* Point Appeal Modal */}
      <PointAppealModal
        visible={appealModalVisible}
        event={selectedAppealEvent}
        onClose={handleCloseAppealModal}
        onSubmit={handleSubmitAppeal}
        appealReason={appealReason}
        appealPictureUrl={appealPictureUrl}
        onUpdateReason={setAppealReason}
        onUpdatePictureUrl={setAppealPictureUrl}
        submitting={submittingAppeal}
      />

      {/* Event Feedback Modal */}
      <EventFeedbackModal
        visible={feedbackModalVisible}
        event={selectedFeedbackEvent}
        onClose={handleCloseFeedbackModal}
        onSubmit={handleSubmitFeedback}
        feedbackData={feedbackData}
        onUpdateFeedback={handleUpdateFeedback}
        submitting={submittingFeedback}
      />

      {/* Data Consent Modal - Apple Compliance */}
      <DataConsentModal
        visible={consentModalVisible}
        onAccept={handleConsentAccept}
        onDecline={handleConsentDecline}
        onClose={() => setConsentModalVisible(false)}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8F9FA',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 40,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
    paddingHorizontal: 4,
  },
  headerTitle: {
    fontSize: 32,
    fontWeight: '800',
    color: '#1e293b',
  },
  headerSubtitle: {
    fontSize: 16,
    color: '#64748b',
    fontWeight: '500',
    marginTop: 4,
  },
  logoutButton: {
    backgroundColor: '#f1f5f9',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
  },
  logoutButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#64748b',
    fontWeight: '500',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorText: {
    fontSize: 16,
    color: '#ef4444',
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 24,
  },
  retryButton: {
    backgroundColor: Colors.primary,
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
  actionsSection: {
    marginTop: 24,
    gap: 12,
  },
  actionButton: {
    backgroundColor: '#ffffff',
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  actionButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1e293b',
  },
  dangerButton: {
    borderColor: '#fecaca',
    backgroundColor: '#fef2f2',
  },
  dangerButtonText: {
    color: '#dc2626',
  },
  // Footer styles - Apple compliance
  footerLinks: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 20,
    paddingHorizontal: 16,
    marginTop: 32,
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
  },
  footerLink: {
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  footerLinkText: {
    fontSize: 12,
    color: '#4285F4',
    textDecorationLine: 'underline',
  },
  footerSeparator: {
    fontSize: 12,
    color: '#cbd5e0',
    paddingHorizontal: 4,
  },
  footerVersion: {
    fontSize: 10,
    color: '#94a3b8',
    textAlign: 'center',
    paddingBottom: 32,
  },
});
